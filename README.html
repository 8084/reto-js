<h1 id="usage">Usage</h1>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">(() <span class="op">=&gt;</span> <span class="op">{</span>
    (() <span class="op">=&gt;</span> <span class="op">{</span>
        (() <span class="op">=&gt;</span> <span class="op">{</span>
            <span class="co">// Imagine you need to return a value as a result of</span>
            <span class="co">// the outermost function right from here</span>
        <span class="op">}</span>)()<span class="op">;</span>
        <span class="co">// and make sure that this</span>
    <span class="op">}</span>)()<span class="op">;</span>
    <span class="co">// and this areas of code will not be reached.</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p>off course there is a solution: use one more variable</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">(() <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="kw">var</span> tmp<span class="op">;</span>
    (() <span class="op">=&gt;</span> <span class="op">{</span>
        (() <span class="op">=&gt;</span> <span class="op">{</span>
            tmp <span class="op">=</span> <span class="st">&quot;foo&quot;</span><span class="op">;</span>
            <span class="cf">return</span><span class="op">;</span>
        <span class="op">}</span>)()<span class="op">;</span>

        <span class="cf">if</span> (<span class="kw">typeof</span> tmp <span class="op">!=</span> <span class="st">&#39;undefined&#39;</span>) <span class="op">{</span>
            <span class="cf">return</span><span class="op">;</span>
        <span class="op">}</span>

        <span class="co">// unreachable if `tmp` is set</span>
    <span class="op">}</span>)()<span class="op">;</span>

    <span class="cf">if</span> (<span class="kw">typeof</span> tmp <span class="op">!=</span> <span class="st">&#39;undefined&#39;</span>) <span class="op">{</span>
        <span class="cf">return</span><span class="op">;</span>
    <span class="op">}</span>

    <span class="co">// unreachable if `tmp` is set</span>
<span class="op">}</span>)()<span class="op">;</span></code></pre></div>
<p>but the code seems a little messy now.</p>
<p><code>reto.js</code> allows to do it in a more elegant manner:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">$label</span>(<span class="st">&#39;example&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    (() <span class="op">=&gt;</span> <span class="op">{</span>
        (() <span class="op">=&gt;</span> <span class="op">{</span>
            <span class="at">$return</span>(<span class="st">&#39;example&#39;</span><span class="op">,</span> <span class="st">&#39;some_value&#39;</span>)<span class="op">;</span>
        <span class="op">}</span>)()<span class="op">;</span>
    <span class="op">}</span>)()<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<h1 id="how-it-works">How it works</h1>
<p><code>$return</code> <code>throw</code>s an object containing the return value, that is later <code>catch</code>ed by a function made by <code>$label</code>.</p>
<p>That means, you can't use <code>try .. catch .. finally</code> blocks normally in any code that utilizes <code>reto.js</code>. Since exceptions used to pass values to outer labeled functions mustn't be catched by your code, you need to use <code>$rethrow</code> function provided by the library in the very beginning of every <code>catch</code> block where unwanted exception can appear. <code>$rethrow</code> just rethrows given exception if it was generated by <code>$return</code> and does nothing otherwise.</p>
<p>Example usage:</p>
<pre><code>var r = $label(&#39;foo&#39;, () =&gt; {
    try {
        $return(&#39;foo&#39;, &#39;some-value&#39;);
    } catch (e) {
        $rethrow(e);
        return &#39;another-value&#39;;
    }
});</code></pre>
<p>The above example outputs <code>'some-value</code> as expected.</p>
<h1 id="functions">Functions</h1>
<h2 id="label">$label</h2>
<p>Used to mark given function with label. Order of the arguments is completely ignored. <code>string</code> argument defines label value and <code>bool</code> argument determines if the wrapped function will be returned (<code>true</code>) or will it be called immedeately (<code>false</code>, default behavior).</p>
<h2 id="return">$return</h2>
<p>If called with two arguments, the first argument may be:</p>
<ul>
<li>a label, to which the value need to be returned.</li>
<li>a natural number, defining how many nested levels of <strong>labeled</strong> functions you need to return from.</li>
</ul>
<p>If called with one argument, value will be returned one level up.</p>
<h2 id="rethrow">$rethrow</h2>
<p>Rethrows given exception if it was generated by <code>$return</code> and does nothing otherwise.</p>
